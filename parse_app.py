from os.path import basename, dirname, exists
import sys

def name_output_file(desired_appended_name):
    # File generated by bk7321tools dissect_dump
    if appcode_path.endswith('app_1.00_decrypted.bin'):
        return appcode_path.replace('app_1.00_decrypted.bin', desired_appended_name + ".txt")
    return appcode_path + "_" + desired_appended_name + ".txt"

def read_until_newline(contents: bytes, index):
    strlen = 0
    slice_obj = slice(index, len(contents))
    for b in contents[slice_obj]:
        if b != 10 and b != 13:
            strlen += 1
            continue
        slice_obj = slice(index, index + strlen)
        return contents[slice_obj].decode('utf-8')

def read_until_null(contents: bytes, index):
    strlen = 0
    slice_obj = slice(index, len(contents))
    for b in contents[slice_obj]:
        if b != 0:
            strlen += 1
            continue
        slice_obj = slice(index, index + strlen)
        return contents[slice_obj].decode('utf-8')

def bytecode_search(contents, bytecode: bytes):
    offset = contents.find(bytecode, 0)

    if offset == -1:
        return []

    matches = [offset]
    offset = contents.find(bytecode, offset+1)
    while offset != -1:
        matches.append(offset)
        offset = contents.find(bytecode, offset+1)

    return matches

def read_null_to_null(contents: bytes, index):
    startIndex = index
    while startIndex > 0:
        startIndex -= 1
        if contents[startIndex] == 0:
            break
    # startIndex is now null, start after it
    startIndex += 1
    return read_until_null(contents, startIndex)

def find_device_class(contents, searchPhrase):
    matches = bytecode_search(contents, searchPhrase)
    for match in matches:
        matchText = read_null_to_null(contents, match)
        if matchText == 'BK7231S_2M':
            continue
        if '/' in matchText:
            continue
        return matchText
    return ''

def search_device_class_after_compiled_line(contents):
    compiled_at_string = b'**********[%s] [%s] compiled at %s %s**********'
    offset = contents.find(compiled_at_string, 0) + len(compiled_at_string) + 1
    if offset == -1:
        return ''
    after = read_null_to_null(contents, offset)
    if after.count('_') > 0:
        return after
    return ''

def search_device_class_after_bk7231n(contents):
    compiled_at_string = b'\0bk7231n\0'
    offset = contents.find(compiled_at_string, 0) + len(compiled_at_string) + 1
    if offset == -1:
        return ''
    after = read_null_to_null(contents, offset)
    if after.count('_') > 0:
        return after
    return ''

def search_swv_after_compiled_line(contents):
    compiled_at_string = b'**********[%s] [%s] compiled at %s %s**********'
    offset = contents.find(compiled_at_string, 0)
    if offset == -1:
        return ''
    offset += len(compiled_at_string) + 1
    after = read_null_to_null(contents, offset)
    offset += len(after) + 1
    after_after = read_null_to_null(contents, offset)
    if after_after.count('.') > 1:
        return after_after
    return ''

def search_swv_after_device_class(contents, device_class):
    offset = contents.find(bytes(device_class, 'utf-8'), 0)
    if offset == -1:
        return ''
    offset += len(device_class) + 1
    after = read_null_to_null(contents, offset)
    if after.count('.') > 1:
        return after
    return ''

def dump(file, contents: bytes):
    global base_name, base_folder
    base_name = basename(file)[:-23]
    base_folder = dirname(file)
    sdk_line = ''
    print(f"========== {base_name} ==========")
    if b'< TUYA IOT SDK' in contents:
        sdk_line = read_until_newline(contents, contents.index(b'< TUYA IOT SDK'))
        sdk_version = sdk_line.split()[4].split(':')[1]
        print(f"[+] SDK: {sdk_version}")
        with open(name_output_file("sdk"), 'w') as f:
            f.write(sdk_version)

    device_class_search_keys = [
        b'oem_bk7231s_',
        b'bk7231t_common_',
        b'bk7231s_',
        b'oem_bk7231n_',
        b'bk7231n_common_',
    ]

    device_class = ''

    for searchKey in device_class_search_keys:
        device_class = find_device_class(contents, searchKey)
        if device_class != '':
            break
        
    if device_class == '':
        device_class = search_device_class_after_compiled_line(contents)

    if device_class == '':
        device_class = search_device_class_after_bk7231n(contents)

    if device_class != '':
        print(f"[+] Device class: {device_class}")
        with open(name_output_file("device_class"), 'w') as f:
            f.write(device_class)
        if 'light_ty' in device_class:
            with open(name_output_file("icon"), 'w') as f:
                f.write('lightbulb-outline')
        elif '_plug' in device_class:
            with open(name_output_file("icon"), 'w') as f:
                f.write('power-plug')
        elif 'strip' in device_class:
            with open(name_output_file("icon"), 'w') as f:
                f.write('string-lights')
        elif 'switch' in device_class:
            with open(name_output_file("icon"), 'w') as f:
                f.write('toggle-switch-outline')
        else:
            with open(name_output_file("icon"), 'w') as f:
                f.write('memory')
    else:
        print("[!] Unable to determine device class, please open an issue and include the bin file.")

    # If swv doesn't exist from storage
    if exists(name_output_file("swv")) == False:
        swv = search_swv_after_compiled_line(contents)
        if swv == '':
            swv = search_swv_after_device_class(contents, device_class)
        if swv != '':
            print(f"[+] Version: {swv}")
            with open(name_output_file("swv"), 'w') as f:
                f.write(swv)

    # If bv doesn't exist from storage
    if exists(name_output_file("bv")) == False:
        bv = sdk_line.split()[5].split('_')[0].split(':')[1]
        if bv is not None and bv != '':
            print(f"[+] bv: {bv}")
            with open(name_output_file("bv"), 'w') as f:
                f.write(bv)
    
if __name__ == '__main__':
    if not sys.argv[1:]:
        print('Usage: python parse_app.py <dercypted app file>')
        sys.exit(1)

    global appcode_path
    appcode_path = sys.argv[1]
    with open(appcode_path, 'rb') as fs:
        appcode = fs.read()
        dump(appcode_path, appcode)